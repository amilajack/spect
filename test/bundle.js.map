{"version":3,"file":"","sourceRoot":"","sources":["..\\node_modules\\tape-modern\\dist\\tape-modern.umd.js","..\\src\\htm.js","htm.js","index.js"],"sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.tape = {})));\n}(this, (function (exports) { 'use strict';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\nvar fulfil;\nvar done = new Promise(function (f) {\n    fulfil = f;\n});\nfunction start() {\n    if (!running) {\n        running = true;\n        console.log('TAP version 13');\n        Promise.resolve().then(function () {\n            var hasOnly = tests.some(function (test) { return test.only; });\n            tests.forEach(function (test) {\n                test.shouldRun = test.skip\n                    ? false\n                    : hasOnly ? test.only : true;\n            });\n            dequeue();\n        });\n    }\n}\nvar test = Object.assign(function test(name, fn) {\n    tests.push({ name: name, fn: fn, skip: false, only: false, shouldRun: false });\n    start();\n}, {\n    skip: function (name, fn) {\n        tests.push({ name: name, fn: fn, skip: true, only: false, shouldRun: null });\n        start();\n    },\n    only: function (name, fn) {\n        tests.push({ name: name, fn: fn, skip: false, only: true, shouldRun: null });\n        start();\n    }\n});\nvar testIndex = 0;\nvar assertIndex = 0;\nvar running = false;\nvar tests = [];\nvar passed = 0;\nvar failed = 0;\nvar skipped = 0;\nvar isNode = typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]';\nfunction logResult(ok, operator, msg, info) {\n    if (info === void 0) { info = {}; }\n    assertIndex += 1;\n    if (ok) {\n        console.log(\"ok \" + assertIndex + \" \\u2014 \" + msg);\n        passed += 1;\n    }\n    else {\n        console.log(\"not ok \" + assertIndex + \" \\u2014 \" + msg);\n        failed += 1;\n        console.log('  ---');\n        console.log(\"  operator: \" + operator);\n        if (isNode) {\n            var util = require('util');\n            if ('expected' in info)\n                console.log(\"  expected:\\n    \" + util.format(info.expected).replace(/\\n/gm, \"\\n    \"));\n            if ('actual' in info)\n                console.log(\"  actual:\\n    \" + util.format(info.actual).replace(/\\n/gm, \"\\n    \"));\n        }\n        else {\n            if ('expected' in info)\n                console.log(\"  expected:\", info.expected);\n            if ('actual' in info)\n                console.log(\"  actual:\", info.actual);\n        }\n        // find where the error occurred, and try to clean it up\n        var lines = new Error().stack.split('\\n').slice(3);\n        var cwd_1 = '';\n        if (isNode) {\n            cwd_1 = process.cwd();\n            if (/[\\/\\\\]/.test(cwd_1[0]))\n                cwd_1 += cwd_1[0];\n            var dirname = typeof __dirname === 'string' && __dirname.replace(/dist$/, '');\n            for (var i = 0; i < lines.length; i += 1) {\n                if (~lines[i].indexOf(dirname)) {\n                    lines = lines.slice(0, i);\n                    break;\n                }\n            }\n        }\n        var stack = lines\n            .map(function (line) { return \"    \" + line.replace(cwd_1, '').trim(); })\n            .join('\\n');\n        console.log(\"  stack:   \\n\" + stack);\n        console.log(\"  ...\");\n    }\n}\nvar assert = {\n    fail: function (msg) { return logResult(false, 'fail', msg); },\n    pass: function (msg) { return logResult(true, 'pass', msg); },\n    ok: function (value, msg) {\n        if (msg === void 0) { msg = 'should be truthy'; }\n        return logResult(Boolean(value), 'ok', msg, {\n            actual: value,\n            expected: true\n        });\n    },\n    equal: function (a, b, msg) {\n        if (msg === void 0) { msg = 'should be equal'; }\n        return logResult(a === b, 'equal', msg, {\n            actual: a,\n            expected: b\n        });\n    },\n    throws: function (fn, expected, msg) {\n        if (msg === void 0) { msg = 'should throw'; }\n        try {\n            fn();\n            logResult(false, 'throws', msg, {\n                expected: expected\n            });\n        }\n        catch (err) {\n            if (expected instanceof Error) {\n                logResult(err.name === expected.name, 'throws', msg, {\n                    actual: err.name,\n                    expected: expected.name\n                });\n            }\n            else if (expected instanceof RegExp) {\n                logResult(expected.test(err.toString()), 'throws', msg, {\n                    actual: err.toString(),\n                    expected: expected\n                });\n            }\n            else if (typeof expected === 'function') {\n                logResult(expected(err), 'throws', msg, {\n                    actual: err\n                });\n            }\n            else {\n                throw new Error(\"Second argument to t.throws must be an Error constructor, regex, or function\");\n            }\n        }\n    }\n};\nfunction dequeue() {\n    return __awaiter(this, void 0, void 0, function () {\n        var test, err_1, total;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    test = tests[testIndex++];\n                    if (!test) return [3 /*break*/, 5];\n                    if (!test.shouldRun) {\n                        if (test.skip) {\n                            console.log(\"# skip \" + test.name);\n                        }\n                        skipped += 1;\n                        dequeue();\n                        return [2 /*return*/];\n                    }\n                    console.log(\"# \" + test.name);\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 3, , 4]);\n                    return [4 /*yield*/, test.fn(assert)];\n                case 2:\n                    _a.sent();\n                    return [3 /*break*/, 4];\n                case 3:\n                    err_1 = _a.sent();\n                    failed += 1;\n                    console.log(\"not ok \" + assertIndex + \" \\u2014 \" + err_1.message);\n                    console.error(\"  \" + err_1.stack.replace(/^\\s+/gm, '    '));\n                    return [3 /*break*/, 4];\n                case 4:\n                    dequeue();\n                    return [3 /*break*/, 6];\n                case 5:\n                    total = passed + failed + skipped;\n                    console.log(\"\\n1..\" + total);\n                    console.log(\"# tests \" + total);\n                    if (passed)\n                        console.log(\"# pass \" + passed);\n                    if (failed)\n                        console.log(\"# fail \" + failed);\n                    if (skipped)\n                        console.log(\"# skip \" + skipped);\n                    fulfil();\n                    if (isNode)\n                        process.exit(failed ? 1 : 0);\n                    _a.label = 6;\n                case 6: return [2 /*return*/];\n            }\n        });\n    });\n}\n\nexports.done = done;\nexports.test = test;\nexports.assert = assert;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=tape-modern.umd.js.map\n","/**\r\n * MAXI fork of htm with ordered props (ohtm)\r\n * takes in html`` template literal\r\n * returns hierarchical arrays structure as\r\n * [mainAspect, ...secondaryAspects, children, ...namedAspects]\r\n * eg. ['div', function(){}, value, true, [ 'small', 'red', ...{color: 'red'}], ...{children: []}]\r\n * that's a bit redundant by providing named props, similar to regexp.match, but corresponds to aspects indexes\r\n */\r\n\r\n// commands for eval\r\nconst TAG_SET = 1;\r\nconst PROPS_SET = 2;\r\nconst PROPS_ASSIGN = 3;\r\nconst CHILD_RECURSE = 4;\r\nconst CHILD_APPEND = 0;\r\n\r\n// parsing mode indicates current [transition] logic/state\r\nconst MODE_SLASH = 0;\r\nconst MODE_TEXT = 1;\r\nconst MODE_WHITESPACE = 2;\r\nconst MODE_TAGNAME = 3;\r\nconst MODE_ATTRIBUTE = 4;\r\n\r\n\r\n// turn statics into sequence of commands tuples of a kind\r\n// [..., value, operation, propName?, ...]\r\nfunction parse (statics) {\r\n  let mode = MODE_TEXT;\r\n  let buffer = '';\r\n  let quote = '';\r\n\r\n  // 0 indicates reference to 0 field, which is statics\r\n  let current = [0];\r\n  let char, propName;\r\n\r\n  // commit tuple of specific type\r\n  const commit = field => {\r\n    if (mode === MODE_TEXT && (field || (buffer = buffer.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g,'')))) {\r\n      current.push(field || buffer, CHILD_APPEND);\r\n    }\r\n    else if (mode === MODE_TAGNAME && (field || buffer)) {\r\n      current.push(field || buffer, TAG_SET);\r\n      mode = MODE_WHITESPACE;\r\n    }\r\n    else if (mode === MODE_WHITESPACE && buffer === '...' && field) {\r\n      current.push(field, PROPS_ASSIGN);\r\n    }\r\n    else if (mode === MODE_WHITESPACE && buffer && !field) {\r\n      current.push(true, PROPS_SET, buffer);\r\n    }\r\n    else if (mode === MODE_ATTRIBUTE && propName) {\r\n      current.push(field || buffer, PROPS_SET, propName);\r\n      propName = '';\r\n    }\r\n    // < ${fn} > - anonymous prop\r\n    else if (mode === MODE_WHITESPACE && field) {\r\n      current.push(field, PROPS_SET, '')\r\n    }\r\n    buffer = '';\r\n  };\r\n\r\n  // walk by static parts\r\n  for (let i=0; i<statics.length; i++) {\r\n    if (i) {\r\n      if (mode === MODE_TEXT) {\r\n        commit();\r\n      }\r\n      // write field (insertion) value index (reference)\r\n      commit(i);\r\n    }\r\n\r\n    // accumulate buffer with the next token\r\n    for (let j=0; j<statics[i].length; j++) {\r\n      char = statics[i][j];\r\n\r\n      if (mode === MODE_TEXT) {\r\n        if (char === '<') {\r\n          // commit accumulated text\r\n          commit();\r\n          // create new level (nested array)\r\n          current = [current];\r\n          mode = MODE_TAGNAME;\r\n        }\r\n        else {\r\n          // accumulate text\r\n          buffer += char;\r\n        }\r\n      }\r\n\r\n      // Non-text modes\r\n      // quoted values are accumulated escaped, quotes are ignored\r\n      else if (quote) {\r\n        if (char === quote) {\r\n          quote = '';\r\n        }\r\n        else {\r\n          buffer += char;\r\n        }\r\n      }\r\n      else if (char === '\"' || char === \"'\") {\r\n        quote = char;\r\n      }\r\n      // closed tag turns on the text mode, saves accumulated aspects sequence\r\n      else if (char === '>') {\r\n        commit();\r\n        mode = MODE_TEXT;\r\n      }\r\n      else if (!mode) {\r\n        // Ignore everything until the tag ends\r\n      }\r\n      // assignment puts accumulated buffer value to propName, cleans up buffer\r\n      else if (char === '=') {\r\n        mode = MODE_ATTRIBUTE;\r\n        propName = buffer;\r\n        buffer = '';\r\n      }\r\n      // 0 in child list keeps reference to the parent level\r\n      else if (char === '/') {\r\n        commit();\r\n        // if we've opened level for closing tagname </> - unwrap that\r\n        if (mode === MODE_TAGNAME) {\r\n          current = current[0];\r\n        }\r\n\r\n        let child = current;\r\n        (current = current[0]).push(child, CHILD_RECURSE);\r\n        mode = MODE_SLASH;\r\n      }\r\n      // separate token\r\n      else if (char === ' ' || char === '\\t' || char === '\\n' || char === '\\r') {\r\n        // <a disabled>\r\n        commit();\r\n        mode = MODE_WHITESPACE;\r\n      }\r\n      else {\r\n        buffer += char;\r\n      }\r\n    }\r\n  }\r\n  commit();\r\n\r\n  return current;\r\n};\r\n\r\n\r\n// `fields` is index of values passed from html`field1: ${field1} field2: ${field2}` → `[statics, field1, field2]`\r\n// `current` is tree level with command tuples sequence\r\nfunction evaluate (current, fields) {\r\n  let tag, props = []\r\n  let children = []\r\n\r\n  // start from 1 because 0 is parent\r\n  for (let i = 1; i < current.length; i++) {\r\n    const field = current[i++];\r\n\r\n    // if field is a number - that's a reference to value in tpl fields\r\n    const value = typeof field === 'number' ? fields[field] : field;\r\n\r\n\r\n    if (current[i] === TAG_SET) {\r\n      tag = value\r\n    }\r\n    else if (current[i] === PROPS_SET) {\r\n      props.push(value)\r\n      let name = current[++i]\r\n      if (name) props[name] = value\r\n    }\r\n    else if (current[i] === PROPS_ASSIGN) {\r\n      for (let name in value) {\r\n        props.push(value)\r\n        props[name] = value[name]\r\n      }\r\n    }\r\n    else if (current[i] === CHILD_RECURSE) {\r\n      // code === CHILD_RECURSE\r\n      children.push(evaluate(value, fields));\r\n    }\r\n    else {\r\n      // code === CHILD_APPEND\r\n      children.push(value);\r\n    }\r\n  }\r\n\r\n  return { tag, props, children }\r\n};\r\n\r\n\r\nconst CACHE = {};\r\n\r\n// `statics` is tpl literal parts split by placeholders, eg. `a ${b} c` → [`a `, ` c`]\r\nfunction html (statics) {\r\n  const key = statics.join('')\r\n  const tpl = CACHE[key] || (CACHE[key] = parse(statics))\r\n  return evaluate(tpl, arguments);\r\n}\r\n\r\nexport default html;\r\n","import { test } from './index.js'\r\nimport htm from '../src/htm.js'\r\n\r\nconsole.log(htm)\r\n\r\ntest('empty', () => {\r\n  expect(htm``).toEqual(undefined);\r\n});\r\n\r\n// TODO: htm bugs.\r\n// 1. CACHE doesn't cache\r\n// 2. quotes don't escape themselves\r\n// console.log(h`<a x=\"ab\\\"c\"def />`)\r\n// 3. make anonymous props possible (available by index key)\r\n\r\ntest.only('anonymous attributes', () => {\r\n  console.log(htm`<a x ${() => {}} y=1 z=${2}><b/></a>c`)\r\n})\r\n\r\ntest('single named elements', () => {\r\n  // console.log(h`<a x y=1 z=${2}><b/></a>c`)\r\n  // console.log(h`<a></a>abc`)\r\n  // console.log(h`a${123}c`)\r\n  // console.log(h`${123}`)\r\n  // console.log(h`<a x y=1 z=${2} ...${{}}/>`)\r\n\r\n  t.deepEqual(htm`<div />`, {tag: 'div'});\r\n  expect(htm`<div/>`).toEqual({ tag: 'div', props: null, children: [] });\r\n  expect(htm`<span />`).toEqual({ tag: 'span', props: null, children: [] });\r\n});\r\n\r\ntest('multiple root elements', () => {\r\n  expect(htm`<a /><b></b><c><//>`).toEqual([\r\n    { tag: 'a', props: null, children: [] },\r\n    { tag: 'b', props: null, children: [] },\r\n    { tag: 'c', props: null, children: [] }\r\n  ]);\r\n});\r\n\r\ntest('single dynamic tag name', () => {\r\n  expect(htm`<${'foo'} />`).toEqual({ tag: 'foo', props: null, children: [] });\r\n  function Foo () {}\r\n  expect(htm`<${Foo} />`).toEqual({ tag: Foo, props: null, children: [] });\r\n});\r\n\r\ntest('single boolean prop', () => {\r\n  expect(htm`<a disabled />`).toEqual({ tag: 'a', props: { disabled: true }, children: [] });\r\n});\r\n\r\ntest('two boolean props', () => {\r\n  expect(htm`<a invisible disabled />`).toEqual({ tag: 'a', props: { invisible: true, disabled: true }, children: [] });\r\n});\r\n\r\ntest('single prop with empty value', () => {\r\n  expect(htm`<a href=\"\" />`).toEqual({ tag: 'a', props: { href: '' }, children: [] });\r\n});\r\n\r\ntest('two props with empty values', () => {\r\n  expect(htm`<a href=\"\" foo=\"\" />`).toEqual({ tag: 'a', props: { href: '', foo: '' }, children: [] });\r\n});\r\n\r\ntest('single prop with static value', () => {\r\n  expect(htm`<a href=\"/hello\" />`).toEqual({ tag: 'a', props: { href: '/hello' }, children: [] });\r\n});\r\n\r\ntest('single prop with static value followed by a single boolean prop', () => {\r\n  expect(htm`<a href=\"/hello\" b />`).toEqual({ tag: 'a', props: { href: '/hello', b: true }, children: [] });\r\n});\r\n\r\ntest('two props with static values', () => {\r\n  expect(htm`<a href=\"/hello\" target=\"_blank\" />`).toEqual({ tag: 'a', props: { href: '/hello', target: '_blank' }, children: [] });\r\n});\r\n\r\ntest('single prop with dynamic value', () => {\r\n  expect(htm`<a href=${'foo'} />`).toEqual({ tag: 'a', props: { href: 'foo' }, children: [] });\r\n});\r\n\r\ntest('two props with dynamic values', () => {\r\n  function onClick(e) { }\r\n  expect(htm`<a href=${'foo'} onClick=${onClick} />`).toEqual({ tag: 'a', props: { href: 'foo', onClick }, children: [] });\r\n});\r\n\r\ntest('prop with quoted dynamic value ignores static parts', () => {\r\n  expect(htm`<a href=\"before${'foo'}after\" a=\"b\" />`).toEqual({ tag: 'a', props: { href: 'foo', a: 'b' }, children: [] });\r\n});\r\n\r\ntest('spread props', () => {\r\n  expect(htm`<a ...${{ foo: 'bar' }} />`).toEqual({ tag: 'a', props: { foo: 'bar' }, children: [] });\r\n  expect(htm`<a b ...${{ foo: 'bar' }} />`).toEqual({ tag: 'a', props: { b: true, foo: 'bar' }, children: [] });\r\n  expect(htm`<a b c ...${{ foo: 'bar' }} />`).toEqual({ tag: 'a', props: { b: true, c: true, foo: 'bar' }, children: [] });\r\n  expect(htm`<a ...${{ foo: 'bar' }} b />`).toEqual({ tag: 'a', props: { b: true, foo: 'bar' }, children: [] });\r\n  expect(htm`<a b=\"1\" ...${{ foo: 'bar' }} />`).toEqual({ tag: 'a', props: { b: '1', foo: 'bar' }, children: [] });\r\n  expect(htm`<a x=\"1\"><b y=\"2\" ...${{ c: 'bar' }}/></a>`).toEqual(h('a', { x: '1' }, h('b', { y: '2', c: 'bar' }) ));\r\n  expect(htm`<a b=${2} ...${{ c: 3 }}>d: ${4}</a>`).toEqual(h('a',{ b: 2, c: 3 }, 'd: ', 4));\r\n  expect(htm`<a ...${{ c: 'bar' }}><b ...${{ d: 'baz' }}/></a>`).toEqual(h('a', { c: 'bar' }, h('b', { d: 'baz' }) ));\r\n});\r\n\r\ntest('multiple spread props in one element', () => {\r\n  expect(htm`<a ...${{ foo: 'bar' }} ...${{ quux: 'baz' }} />`).toEqual({ tag: 'a', props: { foo: 'bar', quux: 'baz' }, children: [] });\r\n});\r\n\r\ntest('mixed spread + static props', () => {\r\n  expect(htm`<a b ...${{ foo: 'bar' }} />`).toEqual({ tag: 'a', props: { b: true, foo: 'bar' }, children: [] });\r\n  expect(htm`<a b c ...${{ foo: 'bar' }} />`).toEqual({ tag: 'a', props: { b: true, c: true, foo: 'bar' }, children: [] });\r\n  expect(htm`<a ...${{ foo: 'bar' }} b />`).toEqual({ tag: 'a', props: { b: true, foo: 'bar' }, children: [] });\r\n  expect(htm`<a ...${{ foo: 'bar' }} b c />`).toEqual({ tag: 'a', props: { b: true, c: true, foo: 'bar' }, children: [] });\r\n});\r\n\r\ntest('closing tag', () => {\r\n  expect(htm`<a></a>`).toEqual({ tag: 'a', props: null, children: [] });\r\n  expect(htm`<a b></a>`).toEqual({ tag: 'a', props: { b: true }, children: [] });\r\n});\r\n\r\ntest('auto-closing tag', () => {\r\n  expect(htm`<a><//>`).toEqual({ tag: 'a', props: null, children: [] });\r\n});\r\n\r\ntest('text child', () => {\r\n  expect(htm`<a>foo</a>`).toEqual({ tag: 'a', props: null, children: ['foo'] });\r\n  expect(htm`<a>foo bar</a>`).toEqual({ tag: 'a', props: null, children: ['foo bar'] });\r\n  expect(htm`<a>foo \"<b /></a>`).toEqual({ tag: 'a', props: null, children: ['foo \"', { tag: 'b', props: null, children: [] }] });\r\n});\r\n\r\ntest('dynamic child', () => {\r\n  expect(htm`<a>${'foo'}</a>`).toEqual({ tag: 'a', props: null, children: ['foo'] });\r\n});\r\n\r\ntest('mixed text + dynamic children', () => {\r\n  expect(htm`<a>${'foo'}bar</a>`).toEqual({ tag: 'a', props: null, children: ['foo', 'bar'] });\r\n  expect(htm`<a>before${'foo'}after</a>`).toEqual({ tag: 'a', props: null, children: ['before', 'foo', 'after'] });\r\n  expect(htm`<a>foo${null}</a>`).toEqual({ tag: 'a', props: null, children: ['foo', null] });\r\n});\r\n\r\ntest('element child', () => {\r\n  expect(htm`<a><b /></a>`).toEqual(h('a', null, h('b', null)));\r\n});\r\n\r\ntest('multiple element children', () => {\r\n  expect(htm`<a><b /><c /></a>`).toEqual(h('a', null, h('b', null), h('c', null)));\r\n  expect(htm`<a x><b y /><c z /></a>`).toEqual(h('a', { x: true }, h('b', { y: true }), h('c', { z: true })));\r\n  expect(htm`<a x=1><b y=2 /><c z=3 /></a>`).toEqual(h('a', { x: '1' }, h('b', { y: '2' }), h('c', { z: '3' })));\r\n  expect(htm`<a x=${1}><b y=${2} /><c z=${3} /></a>`).toEqual(h('a', { x: 1 }, h('b', { y: 2 }), h('c', { z: 3 })));\r\n});\r\n\r\ntest('mixed typed children', () => {\r\n  expect(htm`<a>foo<b /></a>`).toEqual(h('a', null, 'foo', h('b', null)));\r\n  expect(htm`<a><b />bar</a>`).toEqual(h('a', null, h('b', null), 'bar'));\r\n  expect(htm`<a>before<b />after</a>`).toEqual(h('a', null, 'before', h('b', null), 'after'));\r\n  expect(htm`<a>before<b x=1 />after</a>`).toEqual(h('a', null, 'before', h('b', { x: '1' }), 'after'));\r\n  expect(htm`\r\n    <a>\r\n      before\r\n      ${'foo'}\r\n      <b />\r\n      ${'bar'}\r\n      after\r\n    </a>\r\n  `).toEqual(h('a', null, 'before', 'foo', h('b', null), 'bar', 'after'));\r\n});\r\n\r\ntest('hyphens (-) are allowed in attribute names', () => {\r\n  expect(htm`<a b-c></a>`).toEqual(h('a', { 'b-c': true }));\r\n});\r\n\r\ntest('NUL characters are allowed in attribute values', () => {\r\n  expect(htm`<a b=\"\\0\"></a>`).toEqual(h('a', { b: '\\0' }));\r\n  expect(htm`<a b=\"\\0\" c=${'foo'}></a>`).toEqual(h('a', { b: '\\0', c: 'foo' }));\r\n});\r\n\r\ntest('NUL characters are allowed in text', () => {\r\n  expect(htm`<a>\\0</a>`).toEqual(h('a', null, '\\0'));\r\n  expect(htm`<a>\\0${'foo'}</a>`).toEqual(h('a', null, '\\0', 'foo'));\r\n});\r\n\r\ntest('cache key should be unique', () => {\r\n  htm`<a b=\"${'foo'}\" />`;\r\n  expect(htm`<a b=\"\\0\" />`).toEqual(h('a', { b: '\\0' }));\r\n  expect(htm`<a>${''}9aaaaaaaaa${''}</a>`).not.toEqual(htm`<a>${''}0${''}aaaaaaaaa${''}</a>`);\r\n  expect(htm`<a>${''}0${''}aaaaaaaa${''}</a>`).not.toEqual(htm`<a>${''}.8aaaaaaaa${''}</a>`);\r\n});\r\n\r\ntest('do not mutate spread variables', () => {\r\n  const obj = {};\r\n  htm`<a ...${obj} b=\"1\" />`;\r\n  expect(obj).toEqual({});\r\n});\r\n","import {test, assert} from 'tape-modern'\r\n\r\n// assert.deepEqual = (a, b, msg) => {\r\n//   for (let i = 0; i < Math.max(a.length, b.length); i++) {\r\n//     if (a[i] !== b[i]) {\r\n//       console.error('Not deepEqual', a, b)\r\n//       throw Error(msg)\r\n//     }\r\n//   }\r\n// }\r\n\r\n// // tick is required to let mutation pass\r\n// export function delay (delay=0) { return new Promise((ok) => setTimeout(ok, delay))}\r\n// export { test }\r\n\r\n// export const tick = delay()\r\n\r\nimport './htm.js'\r\n// import ('./mount.js')\r\n// import('./core.js')\r\n// import('./selector.js')\r\n\r\n\r\n// props\r\n// apply to target\r\n// apply to selector\r\n// CRUD\r\n// updating causes change\r\n\r\n\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC5QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;"}